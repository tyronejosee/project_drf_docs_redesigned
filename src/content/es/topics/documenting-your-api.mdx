---
title: "Documentando tu API"
keywords: ["django", "rest", "framework", "api", "documenting"]
order: 1
---

# Documentando tu API

> Una API REST debería dedicar casi todo su esfuerzo descriptivo a definir los tipos de medios utilizados para representar recursos y controlar el estado de la aplicación.
>
> &mdash; Roy Fielding, [Las APIs REST deben estar impulsadas por hipertexto][cite]

REST framework ofrece una variedad de opciones diferentes para documentar tu API. La siguiente es una lista no exhaustiva de las más populares.

## Paquetes de terceros para soporte OpenAPI

### drf-spectacular

[drf-spectacular][drf-spectacular] es una biblioteca de generación de esquemas [OpenAPI 3][open-api] con un enfoque explícito en la extensibilidad, personalización y generación de clientes. Es la forma recomendada de generar y presentar esquemas OpenAPI.

La biblioteca tiene como objetivo extraer la mayor cantidad de información de esquema posible, al mismo tiempo que proporciona decoradores y extensiones para una fácil personalización. Tiene soporte explícito para [swagger-codegen][swagger], [SwaggerUI][swagger-ui] y [Redoc][redoc], i18n, control de versiones, autenticación, polimorfismo (solicitudes y respuestas dinámicas), parámetros de consulta/ruta/encabezado, documentación y más. También es compatible con varios complementos populares para DRF listos para usar.

### drf-yasg

[drf-yasg][drf-yasg] es una herramienta de generación [Swagger / OpenAPI 2][swagger] implementada sin usar la generación de esquemas proporcionada por Django Rest Framework.

Su objetivo es implementar la mayor parte posible de la especificación [OpenAPI 2][open-api]: esquemas anidados, modelos con nombre, cuerpos de respuesta, validadores de enumeración/patrón/mínimo/máximo, parámetros de formulario, etc., y generar documentos utilizables con herramientas de generación de código como `swagger-codegen`.

Esto también se traduce en un visor de documentación interactivo muy útil en forma de `swagger-ui`:

![Captura de pantalla - drf-yasg][image-drf-yasg]

---

## Generación de esquemas OpenAPI integrada (obsoleta)

**Aviso de obsolescencia: El soporte integrado de REST framework para generar esquemas OpenAPI está obsoleto en favor de paquetes de terceros que puedan proporcionar esta funcionalidad. Como reemplazo, recomendamos usar el paquete [drf-spectacular](#drf-spectacular).**

Existen varios paquetes disponibles que te permiten generar páginas de documentación HTML a partir de esquemas OpenAPI.

Dos opciones populares son [Swagger UI][swagger-ui] y [ReDoc][redoc].

Ambas requieren poco más que la ubicación de tu archivo de esquema estático o el punto final dinámico `SchemaView`.

### Un ejemplo mínimo con Swagger UI

Suponiendo que hayas seguido el ejemplo de la documentación de esquemas para enrutar una `SchemaView` dinámica, una plantilla de Django mínima para usar Swagger UI podría ser esta:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Swagger</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      rel="stylesheet"
      type="text/css"
      href="//unpkg.com/swagger-ui-dist@3/swagger-ui.css"
    />
  </head>
  <body>
    <div id="swagger-ui"></div>
    <script src="//unpkg.com/swagger-ui-dist@3/swagger-ui-bundle.js"></script>
    <script>
      const ui = SwaggerUIBundle({
        url: "{% url schema_url %}",
        dom_id: "#swagger-ui",
        presets: [
          SwaggerUIBundle.presets.apis,
          SwaggerUIBundle.SwaggerUIStandalonePreset,
        ],
        layout: "BaseLayout",
        requestInterceptor: (request) => {
          request.headers["X-CSRFToken"] = "{{ csrf_token }}";
          return request;
        },
      });
    </script>
  </body>
</html>
```

Guarda esto en tu carpeta de plantillas como `swagger-ui.html`. Luego, enruta un `TemplateView` en la configuración de URL de tu proyecto:

```python
from django.views.generic import TemplateView

urlpatterns = [
    # ...
    # Enruta TemplateView para servir la plantilla de Swagger UI.
    #   * Proporciona `extra_context` con el nombre de la vista de `SchemaView`.
    path(
        "swagger-ui/",
        TemplateView.as_view(
            template_name="swagger-ui.html",
            extra_context={"schema_url": "openapi-schema"},
        ),
        name="swagger-ui",
    ),
]
```

Consulta la [documentación de Swagger UI][swagger-ui] para usos avanzados.

### Un ejemplo mínimo con ReDoc

Suponiendo que hayas seguido el ejemplo de la documentación de esquemas para enrutar una `SchemaView` dinámica, una plantilla de Django mínima para usar ReDoc podría ser esta:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>ReDoc</title>
    <!-- necesario para diseño adaptativo -->
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700"
      rel="stylesheet"
    />
    <!-- ReDoc no cambia los estilos de la página exterior -->
    <style>
      body {
        margin: 0;
        padding: 0;
      }
    </style>
  </head>
  <body>
    <redoc spec-url="{% url schema_url %}"></redoc>
    <script src="https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js"></script>
  </body>
</html>
```

Guarda esto en tu carpeta de plantillas como `redoc.html`. Luego, enruta un `TemplateView` en la configuración de URL de tu proyecto:

```python
from django.views.generic import TemplateView

urlpatterns = [
    # ...
    # Enruta TemplateView para servir la plantilla de ReDoc.
    #   * Proporciona `extra_context` con el nombre de la vista de `SchemaView`.
    path(
        "redoc/",
        TemplateView.as_view(
            template_name="redoc.html",
            extra_context={"schema_url": "openapi-schema"}
        ),
        name="redoc",
    ),
]
```

Consulta la [documentación de ReDoc][redoc] para usos avanzados.

## APIs auto-documentadas

La API navegable que proporciona REST framework permite que tu API sea completamente auto-documentada. La documentación para cada punto final de la API se puede proporcionar simplemente visitando la URL en tu navegador.

![Captura de pantalla - API auto-documentada][image-self-describing-api]

---

#### Configuración del título

El título que se utiliza en la API navegable se genera a partir del nombre de la clase de vista o función. Cualquier sufijo `View` o `ViewSet` se elimina, y la cadena se separa con espacios en los límites de mayúsculas/minúsculas o guiones bajos.

Por ejemplo, la vista `UserListView` se nombrará `User List` cuando se presente en la API navegable.

Cuando se trabaja con viewsets, se agrega un sufijo apropiado a cada vista generada. Por ejemplo, el viewset `UserViewSet` generará vistas llamadas `User List` y `User Instance`.

#### Configuración de la descripción

La descripción en la API navegable se genera a partir del docstring de la vista o viewset.

Si está instalada la biblioteca de Python `Markdown`, se puede usar la [sintaxis de markdown][markdown] en el docstring, y se convertirá a HTML en la API navegable. Por ejemplo:

```python
class AccountListView(views.APIView):
    """
    Devuelve una lista de todas las cuentas **activas** en el sistema.

    Para más detalles sobre cómo se activan las cuentas, por favor [consulta aquí][ref].

    [ref]: http://example.com/activating-accounts
    """
```

Ten en cuenta que cuando se usan viewsets, el docstring básico se utiliza para todas las vistas generadas. Para proporcionar descripciones para cada vista, como para las vistas de lista y recuperación, usa secciones de docstring como se describe en [Esquemas como documentación: Ejemplos][schemas-examples].

#### El método `OPTIONS`

Las APIs de REST framework también admiten descripciones accesibles mediante programación, utilizando el método HTTP `OPTIONS`. Una vista responderá a una solicitud `OPTIONS` con metadatos que incluyen el nombre, la descripción y los diversos tipos de medios que acepta y con los que responde.

Cuando se utilizan las vistas genéricas, cualquier solicitud `OPTIONS` también responderá con metadatos sobre las acciones `POST` o `PUT` disponibles, describiendo qué campos están en el serializador.

Puedes modificar el comportamiento de respuesta a las solicitudes `OPTIONS` sobrescribiendo el método `options` de la vista y/o proporcionando una clase Metadata personalizada. Por ejemplo:

```python
def options(self, request, *args, **kwargs):
    """
    No incluir la descripción de la vista en las respuestas OPTIONS.
    """
    meta = self.metadata_class()
    data = meta.determine_metadata(request, self)
    data.pop('description')
    return Response(data=data, status=status.HTTP_200_OK)
```

Consulta la [documentación de Metadata][metadata-docs] para obtener más detalles.

---

## El enfoque de hipermedia

Para ser completamente RESTful, una API debe presentar sus acciones disponibles como controles de hipermedia en las respuestas que envía.

En este enfoque, en lugar de documentar los puntos finales de la API disponibles desde el principio, la descripción se concentra en los _tipos de medios_ que se utilizan. Las acciones disponibles que se pueden realizar en cualquier URL no están estrictamente fijas, sino que están disponibles mediante la presencia de controles de enlace y formularios en el documento devuelto.

Para implementar una API de hipermedia, deberás decidir un tipo de medio apropiado para la API y luego implementar un renderizador y un analizador personalizados para ese tipo de medio. La sección [REST, Hipermedia y HATEOAS][hypermedia-docs] de la documentación incluye referencias a lecturas de fondo, así como enlaces a varios formatos de hipermedia.

> &mdash; Roy Fielding, [REST APIs must be hypertext driven][cite]

## Paquetes de terceros para soporte de OpenAPI

### drf-spectacular

[drf-spectacular][drf-spectacular] es una biblioteca de generación de esquemas [OpenAPI 3][open-api] con enfoque explícito en extensibilidad, personalización y generación de clientes. Es la forma recomendada para generar y presentar esquemas OpenAPI.

La biblioteca tiene como objetivo extraer la mayor cantidad de información de esquema posible, mientras proporciona decoradores y extensiones para una fácil personalización. Hay un soporte explícito para [swagger-codegen][swagger], [SwaggerUI][swagger-ui] y [Redoc][redoc], i18n, versionamiento, autenticación, polimorfismo (solicitudes y respuestas dinámicas), parámetros de consulta/camino/encabezado, documentación y más. Se admiten varios plugins populares para DRF de forma predeterminada.
i18n, versioning, authentication, polymorphism (dynamic requests and responses), query/path/header parameters,
documentation and more. Several popular plugins for DRF are supported out-of-the-box as well.

### drf-yasg

[drf-yasg][drf-yasg] is a [Swagger / OpenAPI 2][swagger] generation tool implemented without using the schema generation provided
by Django Rest Framework.

It aims to implement as much of the [OpenAPI 2][open-api] specification as possible - nested schemas, named models,
response bodies, enum/pattern/min/max validators, form parameters, etc. - and to generate documents usable with code
generation tools like `swagger-codegen`.

This also translates into a very useful interactive documentation viewer in the form of `swagger-ui`:

![Screenshot - drf-yasg][image-drf-yasg]

---

## Built-in OpenAPI schema generation (deprecated)

**Deprecation notice: REST framework's built-in support for generating OpenAPI schemas is
deprecated in favor of 3rd party packages that can provide this functionality instead.
As replacement, we recommend using the [drf-spectacular](#drf-spectacular) package.**

There are a number of packages available that allow you to generate HTML
documentation pages from OpenAPI schemas.

Two popular options are [Swagger UI][swagger-ui] and [ReDoc][redoc].

Both require little more than the location of your static schema file or
dynamic `SchemaView` endpoint.

### A minimal example with Swagger UI

Assuming you've followed the example from the schemas documentation for routing
a dynamic `SchemaView`, a minimal Django template for using Swagger UI might be
this:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Swagger</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      rel="stylesheet"
      type="text/css"
      href="//unpkg.com/swagger-ui-dist@3/swagger-ui.css"
    />
  </head>
  <body>
    <div id="swagger-ui"></div>
    <script src="//unpkg.com/swagger-ui-dist@3/swagger-ui-bundle.js"></script>
    <script>
      const ui = SwaggerUIBundle({
        url: "{% url schema_url %}",
        dom_id: "#swagger-ui",
        presets: [
          SwaggerUIBundle.presets.apis,
          SwaggerUIBundle.SwaggerUIStandalonePreset,
        ],
        layout: "BaseLayout",
        requestInterceptor: (request) => {
          request.headers["X-CSRFToken"] = "{{ csrf_token }}";
          return request;
        },
      });
    </script>
  </body>
</html>
```

Save this in your templates folder as `swagger-ui.html`. Then route a
`TemplateView` in your project's URL conf:

```python
from django.views.generic import TemplateView

urlpatterns = [
    # ...
    # Route TemplateView to serve Swagger UI template.
    #   * Provide `extra_context` with view name of `SchemaView`.
    path(
        "swagger-ui/",
        TemplateView.as_view(
            template_name="swagger-ui.html",
            extra_context={"schema_url": "openapi-schema"},
        ),
        name="swagger-ui",
    ),
]
```

See the [Swagger UI documentation][swagger-ui] for advanced usage.

### A minimal example with ReDoc.

Assuming you've followed the example from the schemas documentation for routing
a dynamic `SchemaView`, a minimal Django template for using ReDoc might be
this:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>ReDoc</title>
    <!-- needed for adaptive design -->
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700"
      rel="stylesheet"
    />
    <!-- ReDoc doesn't change outer page styles -->
    <style>
      body {
        margin: 0;
        padding: 0;
      }
    </style>
  </head>
  <body>
    <redoc spec-url="{% url schema_url %}"></redoc>
    <script src="https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js"></script>
  </body>
</html>
```

Save this in your templates folder as `redoc.html`. Then route a `TemplateView`
in your project's URL conf:

```python
from django.views.generic import TemplateView

urlpatterns = [
    # ...
    # Route TemplateView to serve the ReDoc template.
    #   * Provide `extra_context` with view name of `SchemaView`.
    path(
        "redoc/",
        TemplateView.as_view(
            template_name="redoc.html", extra_context={"schema_url": "openapi-schema"}
        ),
        name="redoc",
    ),
]
```

See the [ReDoc documentation][redoc] for advanced usage.

## Self describing APIs

The browsable API that REST framework provides makes it possible for your API to be entirely self describing. The documentation for each API endpoint can be provided simply by visiting the URL in your browser.

![Screenshot - Self describing API][image-self-describing-api]

---

#### Setting the title

The title that is used in the browsable API is generated from the view class name or function name. Any trailing `View` or `ViewSet` suffix is stripped, and the string is whitespace separated on uppercase/lowercase boundaries or underscores.

For example, the view `UserListView`, will be named `User List` when presented in the browsable API.

When working with viewsets, an appropriate suffix is appended to each generated view. For example, the view set `UserViewSet` will generate views named `User List` and `User Instance`.

#### Setting the description

The description in the browsable API is generated from the docstring of the view or viewset.

If the python `Markdown` library is installed, then [markdown syntax][markdown] may be used in the docstring, and will be converted to HTML in the browsable API. For example:

```python
class AccountListView(views.APIView):
    """
    Returns a list of all **active** accounts in the system.

    For more details on how accounts are activated please [see here][ref].

    [ref]: http://example.com/activating-accounts
    """
```

Note that when using viewsets the basic docstring is used for all generated views. To provide descriptions for each view, such as for the list and retrieve views, use docstring sections as described in [Schemas as documentation: Examples][schemas-examples].

#### The `OPTIONS` method

REST framework APIs also support programmatically accessible descriptions, using the `OPTIONS` HTTP method. A view will respond to an `OPTIONS` request with metadata including the name, description, and the various media types it accepts and responds with.

When using the generic views, any `OPTIONS` requests will additionally respond with metadata regarding any `POST` or `PUT` actions available, describing which fields are on the serializer.

You can modify the response behavior to `OPTIONS` requests by overriding the `options` view method and/or by providing a custom Metadata class. For example:

```python
def options(self, request, *args, **kwargs):
    """
    Don't include the view description in OPTIONS responses.
    """
    meta = self.metadata_class()
    data = meta.determine_metadata(request, self)
    data.pop('description')
    return Response(data=data, status=status.HTTP_200_OK)
```

See [the Metadata docs][metadata-docs] for more details.

---

## The hypermedia approach

To be fully RESTful an API should present its available actions as hypermedia controls in the responses that it sends.

In this approach, rather than documenting the available API endpoints up front, the description instead concentrates on the _media types_ that are used. The available actions that may be taken on any given URL are not strictly fixed, but are instead made available by the presence of link and form controls in the returned document.

To implement a hypermedia API you'll need to decide on an appropriate media type for the API, and implement a custom renderer and parser for that media type. The [REST, Hypermedia & HATEOAS][hypermedia-docs] section of the documentation includes pointers to background reading, as well as links to various hypermedia formats.

[cite]: https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven
[hypermedia-docs]: rest-hypermedia-hateoas.md
[metadata-docs]: ../api-guide/metadata.md
[schemas-examples]: ../api-guide/schemas.md#examples
[image-drf-yasg]: ../img/drf-yasg.png
[image-self-describing-api]: ../img/self-describing.png
[drf-yasg]: https://github.com/axnsan12/drf-yasg/
[drf-spectacular]: https://github.com/tfranzel/drf-spectacular/
[markdown]: https://daringfireball.net/projects/markdown/syntax
[open-api]: https://openapis.org/
[redoc]: https://github.com/Rebilly/ReDoc
[swagger]: https://swagger.io/
[swagger-ui]: https://swagger.io/tools/swagger-ui/
