---
title: "T2: Solicitudes y Respuestas"
keywords: ["django", "rest", "framework", "api", "requests", "responses"]
order: 3
---

# Tutorial 2: Solicitudes y Respuestas

A partir de este punto vamos a comenzar realmente a cubrir el núcleo de REST framework.
Introduzcamos un par de bloques de construcción esenciales.

## Objetos Request

REST framework introduce un objeto `Request` que extiende el `HttpRequest` estándar y proporciona un análisis de solicitudes más flexible. La funcionalidad central del objeto `Request` es el atributo `request.data`, que es similar a `request.POST`, pero más útil para trabajar con APIs Web.

```python
request.POST  # Solo maneja datos de formularios. Solo funciona para el método 'POST'.
request.data  # Maneja datos arbitrarios. Funciona para los métodos 'POST', 'PUT' y 'PATCH'.
```

## Objetos Response

REST framework también introduce un objeto `Response`, que es un tipo de `TemplateResponse` que toma contenido sin renderizar y utiliza negociación de contenido para determinar el tipo de contenido correcto que se devolverá al cliente.

```python
return Response(data)  # Renderiza al tipo de contenido solicitado por el cliente.
```

## Códigos de estado

Usar códigos numéricos de estado HTTP en tus vistas no siempre facilita la lectura, y es fácil no notar si te equivocas en un código de error. REST framework proporciona identificadores más explícitos para cada código de estado, como `HTTP_400_BAD_REQUEST` en el módulo `status`. Es una buena idea usar estos de forma consistente en lugar de identificadores numéricos.

## Envolviendo vistas de API

REST framework proporciona dos envoltorios que puedes usar para escribir vistas de API.

1. El decorador `@api_view` para trabajar con vistas basadas en funciones.
2. La clase `APIView` para trabajar con vistas basadas en clases.

Estos envoltorios proporcionan algunas funcionalidades, como asegurarse de que recibas instancias de `Request` en tu vista y añadir contexto a los objetos `Response` para que se pueda realizar la negociación de contenido.

Los envoltorios también proporcionan comportamientos como devolver respuestas `405 Method Not Allowed` cuando corresponde, y manejar cualquier excepción `ParseError` que ocurra al acceder a `request.data` con una entrada malformada.

## Juntándolo todo

Bien, comencemos a usar estos nuevos componentes para refactorizar ligeramente nuestras vistas.

```python
from rest_framework import status
from rest_framework.decorators import api_view
from rest_framework.response import Response
from snippets.models import Snippet
from snippets.serializers import SnippetSerializer


@api_view(['GET', 'POST'])
def snippet_list(request):
    """
    Lista todos los fragmentos de código, o crea un nuevo fragmento.
    """
    if request.method == 'GET':
        snippets = Snippet.objects.all()
        serializer = SnippetSerializer(snippets, many=True)
        return Response(serializer.data)

    elif request.method == 'POST':
        serializer = SnippetSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
```

Nuestra vista de instancia es una mejora respecto al ejemplo anterior. Es un poco más concisa y el código ahora se siente muy similar a cuando trabajamos con la API de Formularios. También estamos usando códigos de estado con nombre, lo que hace que el significado de las respuestas sea más claro.

Aquí está la vista para un fragmento individual, en el módulo `views.py`.

```python
@api_view(['GET', 'PUT', 'DELETE'])
def snippet_detail(request, pk):
    """
    Recupera, actualiza o elimina un fragmento de código.
    """
    try:
        snippet = Snippet.objects.get(pk=pk)
    except Snippet.DoesNotExist:
        return Response(status=status.HTTP_404_NOT_FOUND)

    if request.method == 'GET':
        serializer = SnippetSerializer(snippet)
        return Response(serializer.data)

    elif request.method == 'PUT':
        serializer = SnippetSerializer(snippet, data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    elif request.method == 'DELETE':
        snippet.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
```

Todo esto debería sentirse muy familiar: no es muy diferente de trabajar con vistas normales de Django.

Observa que ya no estamos vinculando explícitamente nuestras solicitudes o respuestas a un tipo de contenido específico. `request.data` puede manejar solicitudes entrantes en `json`, pero también puede manejar otros formatos. De manera similar, estamos devolviendo objetos de respuesta con datos, pero permitiendo que REST framework renderice la respuesta al tipo de contenido correcto por nosotros.

## Añadiendo sufijos de formato opcionales a nuestras URLs

Para aprovechar el hecho de que nuestras respuestas ya no están fijas a un solo tipo de contenido, añadamos soporte para sufijos de formato en nuestros endpoints de API. Usar sufijos de formato nos da URLs que se refieren explícitamente a un formato dado y permite que nuestra API maneje URLs como [http://example.com/api/items/4.json][json-url].

Comienza añadiendo un argumento de palabra clave `format` a ambas vistas, de la siguiente manera.

```python
def snippet_list(request, format=None):
```

y

```python
def snippet_detail(request, pk, format=None):
```

Ahora actualiza ligeramente el archivo `snippets/urls.py`, para añadir un conjunto de `format_suffix_patterns` además de las URLs existentes.

```python
from django.urls import path
from rest_framework.urlpatterns import format_suffix_patterns
from snippets import views

urlpatterns = [
    path('snippets/', views.snippet_list),
    path('snippets/<int:pk>/', views.snippet_detail),
]

urlpatterns = format_suffix_patterns(urlpatterns)
```

No es estrictamente necesario añadir estos patrones de URL adicionales, pero nos da una forma simple y limpia de referirnos a un formato específico.

## ¿Cómo se ve?

Adelante y prueba la API desde la línea de comandos, como hicimos en [la parte 1 del tutorial][tut-1]. Todo funciona de manera bastante similar, aunque ahora tenemos un manejo de errores más agradable si enviamos solicitudes inválidas.

Podemos obtener una lista de todos los fragmentos, como antes.

```bash
http http://127.0.0.1:8000/snippets/

HTTP/1.1 200 OK

```

```json
[
  {
    "id": 1,
    "title": "",
    "code": "foo = \"bar\"\n",
    "linenos": false,
    "language": "python",
    "style": "friendly"
  },
  {
    "id": 2,
    "title": "",
    "code": "print(\"hello, world\")\n",
    "linenos": false,
    "language": "python",
    "style": "friendly"
  }
]
```

Podemos controlar el formato de la respuesta que obtenemos, ya sea usando el encabezado `Accept`:

```bash
http http://127.0.0.1:8000/snippets/ Accept:application/json  # Solicitar JSON
http http://127.0.0.1:8000/snippets/ Accept:text/html         # Solicitar HTML
```

O añadiendo un sufijo de formato:

```bash
http http://127.0.0.1:8000/snippets.json  # Sufijo JSON
http http://127.0.0.1:8000/snippets.api   # Sufijo de API navegable
```

De forma similar, podemos controlar el formato de la solicitud que enviamos usando el encabezado `Content-Type`.

```bash
# POST usando datos de formulario
http --form POST http://127.0.0.1:8000/snippets/ code="print(123)"

{
    "id": 3,
    "title": "",
    "code": "print(123)",
    "linenos": false,
    "language": "python",
    "style": "friendly"
}

# POST usando JSON
http --json POST http://127.0.0.1:8000/snippets/ code="print(456)"

{
    "id": 4,
    "title": "",
    "code": "print(456)",
    "linenos": false,
    "language": "python",
    "style": "friendly"
}
```

Si añades el modificador `--debug` a las solicitudes `http` anteriores, podrás ver el tipo de solicitud en los encabezados de la petición.

Ahora ve y abre la API en un navegador web, visitando [http://127.0.0.1:8000/snippets/][devserver].

### Navegabilidad

Debido a que la API elige el tipo de contenido de la respuesta basándose en la solicitud del cliente, por defecto devolverá una representación en formato HTML del recurso cuando ese recurso sea solicitado por un navegador web. Esto permite que la API devuelva una representación HTML completamente navegable.

Tener una API navegable vía web es una enorme mejora de usabilidad y hace que desarrollar y usar tu API sea mucho más fácil. También reduce drásticamente la barrera de entrada para otros desarrolladores que quieran inspeccionar y trabajar con tu API.

Consulta el tema de la [API navegable][browsable-api] para obtener más información sobre la característica de API navegable y cómo personalizarla.

## ¿Qué sigue?

En [la parte 3 del tutorial][tut-3], comenzaremos a usar vistas basadas en clases y veremos cómo las vistas genéricas reducen la cantidad de código que necesitamos escribir.

[json-url]: http://example.com/api/items/4.json
[devserver]: http://127.0.0.1:8000/snippets/
[browsable-api]: ../topics/browsable-api.md
[tut-1]: 1-serialization.md
[tut-3]: 3-class-based-views.md
